numbers = list(map(int, input("Enter numbers: ").split()))

a = numbers[0]

b = numbers[1]

c = numbers[2]

为解决这个问题，我们需要确定棋局中可能发生的最大平局数，并验证给定的分数 \( p1, p2, \) 和 \( p3 \) 是否可以由三位朋友之间的棋局得出。

关键见解：
1. **理解游戏中的得分**：
   - **胜利**：玩家得 2 分，输家得 0 分。
   - **平局**：参与的两名玩家各得 1 分。
   - 有三对可能进行比赛的玩家组合：(1,2), (1,3), 和 (2,3)。

2. **给定输入的约束**：
   - 分数以非递减顺序提供
   \( p1 > p2 > p3 \)。

3. **游戏分析**：
   - 设定变量：
     - \( x \)：玩家 1 获胜的游戏数。
     - \( y \)：玩家 2 获胜的游戏数。
     - \( z \)：玩家 3 获胜的游戏数。
     - \( d12 \)：玩家 1 和 2 平局的游戏数。
     - \( d13 \)：玩家 1 和 3 平局的游戏数。
     - \( d23 \)：玩家 2 和 3 平局的游戏数。
   - 使用这些变量，得分可以表示为：
   
     p1 = 2x + d12 + d13 

     p2 = 2y + d12 + d23 

     p3 = 2z + d13 + d23 

4. **确定可行性**：
   - 使用得分关系，\( p1 + p2 + p3 \) 必须是偶数（因为每对贡献的点数都是偶数：要么是赢/输的 2 分，要么是平局的 2 分）。
   - 最小得分 \( p1 \) 可以被视为约束：如果 \( p1 \) 可以通过组合平局和偶数游戏来解释，那么它可以验证其余部分。

5. **最大化平局数**：
   - 平局数 \( d12 + d13 + d23 \) 应该最大化。
   - 通过重构得分差异，可以找到每种类型的平局的约束。每场游戏对 \( p3 \) 的贡献最大，其次是 \( p2 \)，最少是 \( p1 \)。

目标是模拟或分析推导出 \( x, y, z, d12, d13, \) 和 \( d23 \) 的可行组合，这些组合将导致得分 \( p1, p2, \) 和 \( p3 \)，并最大化 \( d12 + d13 + d23 \)。如果找不到可行的组合，返回 \(-1\)。